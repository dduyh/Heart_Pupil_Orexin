%% Matlab control NI DAQ board
%
%Author:  Yihui Du
%Date: 	November 13th, 2023

%% Discover Available Devices 
% Use the |daq.getDevices| command to display a list of devices available
% to your machine and MATLAB(R).

clc
clear
daqreset

d = daq.getDevices;
deviceInfo = d(1);
get(deviceInfo)
get(deviceInfo.Subsystems(1))

%% Acquire Data
% To acquire data:
%
% # Create a session describing the operation to perform
% # Add input channels to the session
% # Start the acquisition
%

%%
% The |daq.createSession| command creates a session.  The session contains
% information describing the hardware, scan rate, duration, and other
% properties associated with the acquisition.  Create a session, and assign
% it to a variable.

s = daq.createSession('ni');

%%
% The |addAnalogInputChannel| command attaches an analog input channel to
% the session.  You can add more than one channel to a session. 

addAnalogInputChannel(s,'Dev1',0,'Voltage');

%% Change Default Properties of the Acquisition
% By default, sessions run for one second at 1000 scans per second.  To
% acquire at a higher rate for a longer time, change the |Rate| and
% |DurationInSeconds| properties.

s.Rate = 2000;
s.DurationInSeconds = 5;

%% Start the Session in Foreground
% You can acquire multiple scans using the |startForeground| function. 
% This blocks MATLAB execution until all the data is acquired. The acquired
% data is returned in TIME-DATA pairs. TIME is a M-by-1 matrix, where M is
% the number of scans. DATA is a M-by-N matrix where M is the number of
% scans and N is the number of analog input channels in the session.
% We will now start a foreground operation.

[data,time] = s.startForeground;

plot(time,data);
xlabel('Time (secs)');
ylabel('Voltage')

%% Add Analog Output Channels 
% Use the |addAnalogOutputChannel| function to add two analog output 
% channels from this device to the session.

addAnalogOutputChannel(s,'Dev1',0,'Voltage');  
addAnalogOutputChannel(s,'Dev1',1,'Voltage');
addAnalogOutputChannel(s,'Dev1',2,'Voltage');  

%% Queue the Data
% Use the |queueOutputData| function to generate multiple scans. Data
% should be a M-by-N matrix where M is the number of scans you want and N
% is the number of channels in the session. Generate 2 test signals (a 1Hz
% sine wave and a 1Hz ramp) and output them on to the channels in this
% session. The plot depicts the data generated by both channels together.
% (Check if the device you are using supports simultaneous sampling.)

outputSignal1 = sin(linspace(0,pi*2,s.Rate)');
outputSignal2 = linspace(-1,1,s.Rate)';
plot(outputSignal1);
hold on;
plot(outputSignal2,'-g');
xlabel('Time');
ylabel('Voltage');
legend('Analog Output 0', 'Analog Output 1');
queueOutputData(s,[outputSignal1 outputSignal2]);

%% Start the Session in Foreground
% Use the |startForeground| function to start the analog output 
% operation and block MATLAB execution until all data is generated. 

s.startForeground;

%% Acquire Continuous and Background Data Using NI Devices
%
% This example shows how to acquire analog input data using non-blocking 
% commands. This allows you to continue working in the MATLAB command window 
% during the acquisition. 

%% Plot Live Data as it is Acquired
% When you acquire data in the background, you can provide the acquisition
% session directions to handle the incoming data, using listeners and
% events. A DataAvailable event occurs when a specific amount of data is
% available to the session. A listener can respond to that event and
% initiate specified function.
%
% Use |addlistener| to add an anonymous function to the session. This
% function is called every time the DataAvailable event occurs, and plots
% the acquired data against time. By default this listener is called 10
% times per second.
%
% When you add a listener, a handle to the listener is returned. Save the
% handle in the variable |lh| and delete it later.

lh = addlistener(s,'DataAvailable', @(src,event) plot(event.TimeStamps, event.Data));

%%
% The default rate that the listener is called is 10 times a second.
% However, you can change this my modifying the
% |NotifyWhenDataAvailableExceeds| property.  The listener will be called
% when the number of points accumulated exceeds this value.  In this case,
% we set it to 2000, which results in a frequency of once per second.

s.NotifyWhenDataAvailableExceeds = 2000;

%%
% After you add the listener, start the background acquisition.  When you
% run this example in MATLAB a plot updates 10 times a second. In the
% published version of the example you see two snapshots of the plot: one,
% after the |pause| completes and the other at end of the acquisition.

s.startBackground();

%%
% There are no other calculations to perform and the
% acquisition is set to run for the entire 5 seconds. Wait for the
% acquisition to complete. Call |wait| with no argument, 
% which defaults to an infinite wait time.
% The |wait| command returns as soon as the background acquisition 
% completes.

s.wait()

%%
% Delete the listener so that it does not run with the next acquisition.

delete(lh)

%% Capture a Unique Event in Incoming Data
% In some cases there is no fixed time or number of scans to acquire.
% You may want to acquire continuously until a specific condition is met. In
% this example, acquire until the signal exceeds 1V.

%%
% Reset the rate at which the listener is called to the default of ten times
% per second by setting the |IsNotifyWhenDataAvailableExceedsAuto| property
% to |true|.

s.IsNotifyWhenDataAvailableExceedsAuto = true;

%%
% Configure a new listener to process the incoming data. 

lh = addlistener(s,'DataAvailable', @stopWhenExceedOneV);

%%
% stopWhenExceedOneV is a multi-line function, stored in a separate
% MATLAB file.

type('stopWhenExceedOneV.m')

%%
% Configure the session to acquire continuously. The listener detects the
% 1V event and calls |stop|.

s.IsContinuous = true;
s.startBackground()

%%
% Use |pause| in a loop to monitor the number of scans acquired for the
% duration of the acquisition. Note that the output is mixed in with output
% from the event listener.

while s.IsRunning
    pause(0.5)
    fprintf('While loop: Scans acquired = %d\n', s.ScansAcquired)
end

fprintf('Acquisition has terminated with %d scans acquired\n', s.ScansAcquired);

%%
% Delete the listener.

delete(lh)

%% Generate Continuous and Background Signals Using NI Devices
%
% This example shows how to generate analog output data using non-blocking 
% commands. This allows you to continue working in the MATLAB command window 
% during the generation.  This is called *background generation*.

%% Create Synchronized Signals
% Generate output signals by creating a pattern of 
% data that is repeatedly queued to the output device. The 
% data for each channel is column based and the output signals are 
% synchronized to each other. 
%
% Create 3 waveforms:
%
% * data0: 1 cycle of a sine wave
% * data1: 1 cycle of a sine wave with a 45 degree phase lag
% * data2: 10 cycles of a sine wave
 
data0 = sin(linspace(0, 2*pi, 1001))';
data1 = sin(linspace(0, 2*pi, 1001) + pi/4)';
data2 = sin(linspace(0, 2*pi*10, 1001))';
 
%%
% The above code creates a 1001 point waveform. This is because  
% linspace includes the endpoints, we will have a data point for
% sin(0) and a data point for sin(2*pi). To maintain a coherent signal 
% we delete the last point to end up with 1000 points per waveform.
 
data0(end) = [];
data1(end) = [];
data2(end) = [];
 
%%
% Note that we setup the session to run at a rate of 10,000 scans per second. 
% Since each cycle of the output sine waves is 1000 points, we expect to 
% observe data0 and data1 as 10Hz sine waves, and data2 as a 100Hz sine wave.
 
subplot(3,1,1) 
plot(data0) 
title('data0')
grid on
subplot(3,1,2)
plot(data1)
title('data1')
grid on;
subplot(3,1,3)
plot(data2)
title('data2')
grid on;
 
%% Queue the Output Data and Start Background Generation
% Before starting a continuous generation, queue half a second of data to
% the analog output device's buffer. Then call |startBackground|.
% The session expects the queued output data to be column based, with 
% a column of data for each output channel added to your session.
%
% The |startBackground| command starts the generation and returns control
% to the command line immediately, allowing you to do other operations in
% MATLAB while the generation is running in the background.
 
queueOutputData(s,repmat([data0, data1, data2], 5, 1));
s.startBackground();
 
%%
% You can run other MATLAB commands while the generation is running, or
% optionally call |wait| with no argument, which defaults to an infinite
% wait time. The |wait| command returns as soon as the background
% generation completes.

s.wait()
 
%% Create a Function to Continuously Queue Output Data
% When you generate data in the background, you can provide the acquisition
% session directions to handle the outgoing data, using listeners and
% events. For example, you can continuously generate the output signal by
% queuing output data repeatedly. A DataRequired event occurs indicating
% that we need to queue more data to the device. A listener can respond to
% that event and initiate specified function.
%
% Use addListener to add an anonymous function to the session and assign it
% to the DataRequired event. The event calls the anonymous function
% repeatedly to queue more data to the output queue, thus creating
% continuous signal generation.
%
% Save the listener handle in the variable |lh| that you will delete later.

lh = addlistener(s,'DataRequired', ...
    @(src,event) src.queueOutputData([data0, data1, data2]));
 
%% Setup the Session and Start the Continuous Generation
% For continuous generation: 
%
% * Set the session to continuous mode
% * Queue the output data
% * call |startBackground|

s.IsContinuous = true; 
queueOutputData(s,repmat([data0, data1, data2], 5, 1));
s.startBackground();
 
%%
% *Note*: In continuous generation, always feed adequate data to the 
% device. If you output data at a rate much 
% higher than the amount of data you are queuing to the device, the device 
% may run out of data to output, resulting in an underflow error. Refer to
% the CompactDAQ documentation for more details.
 
%% Stop the Continuous Background Generation
% Continuous generation runs in parallel with other operations in
% MATLAB. Explicitly call |stop| to end the background generation. Delete
% the listener in the end.

s.stop();
delete(lh);
 
%% Generate Output Data Dynamically Using MATLAB Functions  
% To dynamically generate the output data using 
% a MATLAB function instead of a simple one line anonymous function
% add a listener event handler.
%
%    lh = addlistener(s,'DataRequired', @myFunction);
%        function myFunction(src, event)
%            % Your algorithm to dynamically generate the data
%            % 
%            queueOutputData(src,[data0, data1, data2]);
%        end

%% Measure Angular Position with an Incremental Rotary Encoder
%
% This example shows how to acquire angular position data using an
% incremental rotary encoder and a multifunction data acquisition (DAQ) 
% device with the Data Acquisition Toolbox quadrature encoder measurement 
% functionality.
%
% An incremental rotary encoder is typically mounted on the shaft of a 
% mechanical system, such as a wind turbine or a robotic arm, to provide  
% motion or position information. The encoder 
% outputs two quadrature signals, which provide information on the relative 
% change in position and the direction of rotation.
% The counter subsystem of the DAQ device uses the signals
% output by the encoder to calculate the change in position, and keep track
% of the most recent position value. In MATLAB, a counter input channel
% is used to read the position values.

%% Create a data acquisition session
% Create a session for |ni| and add a counter input channel for |Position|
% measurement type.

ch1 = addCounterInputChannel(s, 'Dev1', 0, 'Position')

%% Configure hardware
% A rotary quadrature encoder outputs two quadrature signals, A and B, which
% provide information on the relative change in position and the direction
% of rotation. Optionally, some models also output an index or reference
% signal, Z, which is active once per revolution. You can use this to reset
% the counter position to a known reference value.
%
% Connect A, B, and Z signal outputs to the proper input
% terminals specified by the DAQ device datasheet (PFI8, PFI10, and PFI9
% for NI USB-6255).

ch1.TerminalA
ch1.TerminalB
ch1.TerminalZ

%%
% Configure quadrature cycle encoding type (X1, X2, or X4).
% This corresponds to the number of counts (counter value increments or decrements)
% for each quadrature cycle (1, 2, or 4.)

ch1.EncoderType = 'X1';

%% Read encoder position on demand 
% The DAQ device counter hardware keeps track of the relative position
% changes signaled by the encoder. Use |inputSingleScan| to read an updated
% position from the counter input channel.

encoderPosition = inputSingleScan(s)

%%
% This example uses an optical encoder model with a resolution of 2500 
% quadrature cycles per shaft revolution, as specified in the encoder datasheet. 
%
% Convert counter values to angular position (in degrees) using the encoder
% resolution and the encoding type ('X1' in this case).

encoderCPR = 360;
encoderPositionDeg = encoderPosition * 360/encoderCPR

%% Acquire hardware-timed encoder position data
% For applications where high time-resolution is required the data
% acquisition must be hardware-timed (clocked). As proof of concept, this 
% example characterizes the motion of a swinging pendulum by measuring
% its angular position vs. time.
%%
% To acquire hardware-timed data from a counter input channel, NI devices
% require the use of an external clock or the use of a clock from another
% subsystem. 
% 
% Add an analog input channel to the session to automatically
% share this system's scan clock.

addAnalogInputChannel(s, 'Dev1', 0, 'Voltage');

%%
% Configure acquisition rate (samples/s) and acquisition duration in
% seconds.

s.Rate = 10000;
s.DurationInSeconds = 35;

%%
% Acquire data in the foreground.

[positionData, timestamps] = startForeground(s);

%%
% By default, counter position readings are unsigned integer values. 
% The counter channels of the DAQ device used in this example are 32-bit, 
% so any counter value read will be in the range 0 to 2^32-1.
% Depending on the application, you may want to obtain signed position values 
% (positive or negative) as decrementing the counter value past zero is a
% discontinuous wraparound to 2^32-1.
% 
% For 32-bit counter channels, use 2^31 as the threshold counter value 
% for conversion to signed position values. The result is valid if the 
% actual position value is in the range -2^31+1 to 2^31.

counterNBits = 32;
signedThreshold = 2^(counterNBits-1);
signedData = positionData(:,1);
signedData(signedData > signedThreshold) = signedData(signedData > signedThreshold) - 2^counterNBits;

%%
% Calculate encoder position data in degrees.

positionDataDeg = signedData * 360/encoderCPR;

%%
% Plot the signed angular position data acquired for the oscillatory 
% motion of a pendulum.

figure; plot(timestamps, positionDataDeg);
xlabel('Time (s)');
ylabel('Angular position (deg.)');

%% Control Stepper Motor using Digital Outputs
%
% This example shows how to control a stepper motor using digital output
% ports.

%% Add Digital Output Only Channels
%
% Create a session, and add 4 digital channels on port 0, lines 0-3.  Set
% the measurement type to |OutputOnly|.  These are connected to the four
% control lines for the stepper motor.

addDigitalChannel(s,'Dev1','port0/line0','OutputOnly')

%% Rotate Motor
% Use |outputSingleScan| to output the sequence to turn the motor 72
% degrees counterclockwise.

outputSingleScan(s,1); 

%%
outputSingleScan(s,0); 

